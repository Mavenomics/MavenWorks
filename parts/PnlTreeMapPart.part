{"typeName":"Part","id":"d797f234-88fd-4cb4-a6a5-d279548cab7d","name":"TreeMapPart.part","path":"/parts/TreeMapPart.part","lastModified":"2018-10-27T01:44:07.445Z","data":{"htmlText":"<!DOCTYPE html>\n<!--\nGeneric treemap, based on http://bost.ocks.org/mike/treemap/\n-->\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script src=\"http://code.jquery.com/jquery-1.7.2.min.js\"></script>\n<script src=\"http://d3js.org/d3.v3.min.js\"></script>\n</head>\n<body>\n<div id=\"chart\"></div>\n</body>\n</html>","jsText":"this.initialize = function() {\n    console.log(\"Part Initialized!\");\n}\n\n\nvar defaults = {\n    margin: {top: 24, right: 0, bottom: 0, left: 0},\n    format: \".2f\",\n    title: \"\",\n    width: 960,\n    height: 500\n};\n\nfunction main(o, data) {\n  var root,\n      opts = $.extend(true, {}, defaults, o),\n      formatNumber = d3.format(opts.format),\n      rname = opts.rootname,\n      margin = opts.margin,\n      theight = 36 + 16;\n  $('#chart').width(opts.width).height(opts.height);\n  var width = opts.width - margin.left - margin.right,\n      height = opts.height - margin.top - margin.bottom - theight,\n      transitioning;\n  \n  var color = d3.scale.category20c();\n  \n  var x = d3.scale.linear()\n      .domain([0, width])\n      .range([0, width]);\n  \n  var y = d3.scale.linear()\n      .domain([0, height])\n      .range([0, height]);\n  \n  var treemap = d3.layout.treemap()\n      .children(function(d, depth) { return depth ? null : d._children; })\n      .sort(function(a, b) { return a.value - b.value; })\n      .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))\n      .round(false);\n  \n  var svg = d3.select(\"#chart\").append(\"svg\")\n      .attr(\"width\", width + margin.left + margin.right)\n      .attr(\"height\", height + margin.bottom + margin.top)\n      .style(\"margin-left\", -margin.left + \"px\")\n      .style(\"margin.right\", -margin.right + \"px\")\n    .append(\"g\")\n      .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n      .style(\"shape-rendering\", \"crispEdges\");\n  \n  var grandparent = svg.append(\"g\")\n      .attr(\"class\", \"grandparent\");\n  \n  grandparent.append(\"rect\")\n      .attr(\"y\", -margin.top)\n      .attr(\"width\", width)\n      .attr(\"height\", margin.top);\n  \n  grandparent.append(\"text\")\n      .attr(\"x\", 6)\n      .attr(\"y\", 6 - margin.top)\n      .attr(\"dy\", \".75em\");\n\n  if (opts.title) {\n    $(\"#chart\").prepend(\"<p class='title'>\" + opts.title + \"</p>\");\n  }\n  if (data instanceof Array) {\n    root = { key: rname, values: data };\n  } else {\n    root = data;\n  }\n    \n  initialize(root);\n  accumulate(root);\n  layout(root);\n  display(root);\n\n  if (window.parent !== window) {\n    var myheight = document.documentElement.scrollHeight || document.body.scrollHeight;\n    window.parent.postMessage({height: myheight}, '*');\n  }\n\n  function initialize(root) {\n    root.x = root.y = 0;\n    root.dx = width;\n    root.dy = height;\n    root.depth = 0;\n  }\n\n  // Aggregate the values for internal nodes. This is normally done by the\n  // treemap layout, but not here because of our custom implementation.\n  // We also take a snapshot of the original children (_children) to avoid\n  // the children being overwritten when when layout is computed.\n  function accumulate(d) {\n    return (d._children = d.values)\n        ? d.value = d.values.reduce(function(p, v) { return p + accumulate(v); }, 0)\n        : d.value;\n  }\n\n  // Compute the treemap layout recursively such that each group of siblings\n  // uses the same size (1×1) rather than the dimensions of the parent cell.\n  // This optimizes the layout for the current zoom state. Note that a wrapper\n  // object is created for the parent node for each group of siblings so that\n  // the parent’s dimensions are not discarded as we recurse. Since each group\n  // of sibling was laid out in 1×1, we must rescale to fit using absolute\n  // coordinates. This lets us use a viewport to zoom.\n  function layout(d) {\n    if (d._children) {\n      treemap.nodes({_children: d._children});\n      d._children.forEach(function(c) {\n        c.x = d.x + c.x * d.dx;\n        c.y = d.y + c.y * d.dy;\n        c.dx *= d.dx;\n        c.dy *= d.dy;\n        c.parent = d;\n        layout(c);\n      });\n    }\n  }\n\n  function display(d) {\n    grandparent\n        .datum(d.parent)\n        .on(\"click\", transition)\n      .select(\"text\")\n        .text(name(d));\n\n    var g1 = svg.insert(\"g\", \".grandparent\")\n        .datum(d)\n        .attr(\"class\", \"depth\");\n\n    var g = g1.selectAll(\"g\")\n        .data(d._children)\n      .enter().append(\"g\");\n\n    g.filter(function(d) { return d._children; })\n        .classed(\"children\", true)\n        .on(\"click\", transition);\n\n    var children = g.selectAll(\".child\")\n        .data(function(d) { return d._children || [d]; })\n      .enter().append(\"g\");\n\n    children.append(\"rect\")\n        .attr(\"class\", \"child\")\n        .call(rect)\n      .append(\"title\")\n        .text(function(d) { return d.key + \" (\" + formatNumber(d.value) + \")\"; });\n    children.append(\"text\")\n        .attr(\"class\", \"ctext\")\n        .text(function(d) { return d.key; })\n        .call(text2);\n\n    //This draws translucent rectangles over the group of children.\n    g.append(\"rect\")\n        .attr(\"class\", \"parent\")\n        .call(rect);\n\n    var t = g.append(\"text\")\n        .attr(\"class\", \"ptext\")\n        .attr(\"dy\", \".75em\")\n\n    t.append(\"tspan\")\n        .text(function(d) { return d.key; });\n    t.append(\"tspan\")\n        .attr(\"dy\", \"1.0em\")\n        .text(function(d) { return formatNumber(d.value); });\n    t.call(text);\n\n    heatMapColor = d3.scale.linear().domain([-1, 0, 1])\n      .range([d3.rgb(\"#FF0000\"), d3.rgb(\"#ffffff\"), d3.rgb('#00FF00')]);\n\n    g.selectAll(\"rect\")\n        .filter(\".child\")\n        .style(\"fill\", function(d) { return d.correlation ? heatMapColor(d.correlation) : color(d.key); });\n      \n    g.selectAll(\"rect\")\n        .filter(\".parent\")\n        .style(\"stroke\", function(d) { return \"#000\"; });\n      \n    \n\n    function transition(d) {\n      if (transitioning || !d) return;\n      transitioning = true;\n\n      var g2 = display(d),\n          t1 = g1.transition().duration(750),\n          t2 = g2.transition().duration(750);\n\n      // Update the domain only after entering new elements.\n      x.domain([d.x, d.x + d.dx]);\n      y.domain([d.y, d.y + d.dy]);\n\n      // Enable anti-aliasing during the transition.\n      svg.style(\"shape-rendering\", null);\n\n      // Draw child nodes on top of parent nodes.\n      svg.selectAll(\".depth\").sort(function(a, b) { return a.depth - b.depth; });\n\n      // Fade-in entering text.\n      g2.selectAll(\"text\").style(\"fill-opacity\", 0);\n\n      // Transition to the new view.\n      t1.selectAll(\".ptext\").call(text).style(\"fill-opacity\", 0);\n      t1.selectAll(\".ctext\").call(text2).style(\"fill-opacity\", 0);\n      t2.selectAll(\".ptext\").call(text).style(\"fill-opacity\", 1);\n      t2.selectAll(\".ctext\").call(text2).style(\"fill-opacity\", 1);\n      t1.selectAll(\"rect\").call(rect);\n      t2.selectAll(\"rect\").call(rect);\n\n      // Remove the old node when the transition is finished.\n      t1.remove().each(\"end\", function() {\n        svg.style(\"shape-rendering\", \"crispEdges\");\n        transitioning = false;\n      });\n    }\n\n    return g;\n  }\n\n  function text(text) {\n    text.selectAll(\"tspan\")\n        .attr(\"x\", function(d) { return x(d.x) + 6; })\n    text.attr(\"x\", function(d) { return x(d.x) + 6; })\n        .attr(\"y\", function(d) { return y(d.y) + 6; })\n        .style(\"opacity\", function(d) { return this.getComputedTextLength() < x(d.x + d.dx) - x(d.x) ? 1 : 0; });\n  }\n\n  function text2(text) {\n    text.attr(\"x\", function(d) { return x(d.x + d.dx) - this.getComputedTextLength() - 6; })\n        .attr(\"y\", function(d) { return y(d.y + d.dy) - 6; })\n        .style(\"opacity\", function(d) { return this.getComputedTextLength() < x(d.x + d.dx) - x(d.x) ? 1 : 0; });\n  }\n\n  function rect(rect) {\n    rect.attr(\"x\", function(d) { return x(d.x); })\n        .attr(\"y\", function(d) { return y(d.y); })\n        .attr(\"width\", function(d) { return x(d.x + d.dx) - x(d.x); })\n        .attr(\"height\", function(d) { return y(d.y + d.dy) - y(d.y); });\n  }\n\n  function name(d) {\n    return d.parent\n        ? name(d.parent) + \" / \" + d.key + \" (\" + formatNumber(d.value) + \")\"\n        : d.key + \" (\" + formatNumber(d.value) + \")\";\n  }\n}\nvar treeRows = function(rows) {\n    return rows.map(r => {\n        let o = {\"key\": r.name};\n        if (r.children.length > 0) {\n            o[\"values\"] = treeRows(r.children);\n        } else {\n            o[\"value\"] = r.getValue(0);\n            o[\"correlation\"] = r.getValue(1);\n        }\n        return o;\n    });\n}\nthis.render = function(args) {\n    $(\"#chart\").empty();\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n    let data;\n    if (args[0]) {\n        data = treeRows(args[0].rows);\n        data = data[0];\n    } else {\n        data = {key:\"Total\", values: [{key:\"a\",value:1.235}, {key:\"b\",value:1.235}]};\n    }\n    main({width:width, height:height}, data)\n}\n","cssText":"#chart {\n  background: #fff;\n  font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n}\n\n.title {\n    font-weight: bold;\n    font-size: 24px;\n    text-align: center;\n    margin-top: 6px;\n    margin-bottom: 6px;\n}\ntext {\n  pointer-events: none;\n}\n\n.grandparent text {\n  font-weight: bold;\n}\n\nrect {\n  fill: none;\n  stroke: #fff;\n}\n\nrect.parent,\n.grandparent rect {\n  stroke-width: 2px;\n}\n\nrect.parent {\n    pointer-events: none;\n}\n\n.grandparent rect {\n  fill: orange;\n}\n\n.grandparent:hover rect {\n  fill: #ee9700;\n}\n\n.children rect.parent,\n.grandparent rect {\n  cursor: pointer;\n}\n\n.children rect.parent {\n  fill: #bbb;\n  fill-opacity: .5;\n}\n\n.children:hover rect.child {\n  fill: #bbb;\n}\n\nbody {\n margin: 0px   \n}"},"functionType":"UserDefinedEvalPart","arguments":[{"name":"Input Table","typeAnnotation":"Table","defaultValue":null,"metadata":null}],"returnType":"Any"}